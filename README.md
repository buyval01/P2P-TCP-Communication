# Общение по TCP через посредника
Данный репозиторий является результатом моей лабораторной работы по "Учебной парктике" и первым знакомством с языком Kotlin.   

В задании предлагалось реализовать безопасное сетевое общение между двумя сторонами по публичному каналу, т.е. некий аналог [TLS](https://en.wikipedia.org/wiki/Transport_Layer_Security). Для имитации “публичности” канала предлагалось симулировать посредника, который считывает всю информацию из канала.  

***
## Условие
### Часть 1. Alice

Реализуйте приложение, которое читает текст с `stdin` и отправляет его по протоколу [TCP](https://ru.wikipedia.org/wiki/Transmission_Control_Protocol) на ip адрес и порт, передаваемые параметром приложения. Если адрес не указан, можно использовать `localhost` (127.0.0.1). Поддержите также возможность получать ответ через это же TCP соединение и выводить его в `stdout`. 
[Решение](https://github.com/buyval01/P2P-TCP-Communication/blob/master/src/main/kotlin/Client.kt)
### Часть 2. Bob

Реализуйте приложение, которое слушает входящие TCP соединения на порте, передаваемом параметром приложения. После установки соединения, приложение должно работать как и в предыдущем сценарии - отправлять всё, что приходит из `stdin`, и выводить в `stdout` всё, что принимает по сети.

Обратите внимание, что нет необходимости открывать несколько соединений параллельно. Но после завершения или обрыва соединения нужно продолжать слушать новые входящие соединения.  
[Решение](https://github.com/buyval01/P2P-TCP-Communication/blob/master/src/main/kotlin/Server.kt)
### Часть 3. Mike
Реализуйте приложение, которое будет *“туннелировать”* два TCP соединения и выводить весь трафик, который через него проходит.  

Приложению передаются параметры `self_port`, `dst_address` и `dst_port`. Оно должно слушать входящие соединения на порте `self_port`. После установки нового соединения *A* приложение:
- Устанавливает соединение *B* с `<dst_address>:<dst_port>`
- Все пакеты, приходящие из *A*, выводит в `stdout` и отправляет в *B*
- Все пакеты, приходящие из *B*, выводит в `stdout` и отправляет в *A*

[Решение](https://github.com/buyval01/P2P-TCP-Communication/blob/master/src/main/kotlin/Tunnel.kt)
### Часть 4. Security

Модифицируйте приложения **Alice** и **Bob** так, чтобы **Mike** видел только зашифрованный трафик и не мог его расшифровать. Для этого:
- После установки соединения сгенерируйте общий сессионный ключ *Алисы* и *Боба*, который не сможет узнать *Майк*. Например, можно сгенерировать ключ на стороне *Алисы* и передать его зашифрованным с помощью публичного ключа [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)), который сгенерирует *Боб* (что медленно) или использовать алгоритм [Diffie-Hellman](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange).
- Все последующие сообщения шифруйте каким-нибудь криптостойким алгоритмом симметричного шифрования с использованием сессионного ключа.
- Если полученный ответ на каком-то этапе не соответствует протоколу (например, *Алиса* ожидает, что *Боб* пришлёт свой публичный ключ сразу после подключения, а он ничего не присылает дольше секунды), то следует вывести сообщение об ошибке и завершить работу программы.

---
## Реализация
В качестве алгоритма генерации сессионного ключа был выбран алгоритм [Diiffie-Hellman](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange). Однако реализация не является полной, т.к., вместо честной генерации простого числа `p` и его примитивного корня `g` для каждой сессии, всегда используются параметры, предоставляемые `java.security.KeyPairGenerator` по умолчанию. 
Размер получаемого ключа составляет *64 байта*.

После получения общего сессионного ключа, все сообщения, пересылаемые между пользователями, шифруются с помощью симметричного алгоритма [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard). Так как максимально допустимый размер `Key size` для данного алгоритма составляет *32 байта*, то для шифрования используется не весь сессионный ключ, а лишь какая-то подпоследовательность его байт, длина которой соответсвует максимальному размеру `Key size`. 
Для достижения большей криптостойкости и потенциальной защиты от [replay attack](https://en.wikipedia.org/wiki/Replay_attack) с каждым новым сообщением отправляется `offset` от начала сессионного ключа, начиная с которого следует взять те самые *32 байта*, чтобы расшифровать данное сообщение.

Для инкапсуляции всего вышеописанного мною был реализова класс `MessageTransmmisionProtocol`, который находится в файле [Util.kt](https://github.com/buyval01/P2P-TCP-Communication/blob/master/src/main/kotlin/Util.kt).


